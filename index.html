<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¸€å…ƒä¸€æ¬¡ä¿„ç¾…æ–¯(æ±èˆˆã„šæ°)</title>
    <style>
        :root {
            --bg-color: #1a1a2e;
            --panel-color: #16213e;
            --text-color: #e94560;
            --font-main: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: #fff;
            font-family: var(--font-main);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
        }

        /* é ‚éƒ¨æ§åˆ¶åˆ— */
        #top-bar {
            width: 100%;
            background: #0f3460;
            padding: 5px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
            z-index: 1001;
            height: 50px;
            box-sizing: border-box;
        }

        .audio-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .volume-control {
            display: flex;
            align-items: center;
            gap: 5px;
            margin-left: 5px;
        }

        .volume-slider {
            width: 80px;
            cursor: pointer;
        }

        .title-group {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-grow: 1;
            justify-content: center;
        }

        .btn {
            padding: 5px 12px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: 0.3s;
            font-size: 14px;
            color: white;
        }

        .btn-fullscreen { background: #6c757d; }
        .btn-help { background: #007bff; }
        .btn-start { 
            background: #28a745; 
            padding: 8px 25px;
            font-size: 16px;
            box-shadow: 0 0 15px rgba(40, 167, 69, 0.6);
            white-space: nowrap;
        }
        .btn-restart {
            background: #f39c12;
            padding: 8px 20px;
            font-size: 14px;
            display: none; 
        }
        .btn-audio { background: #533483; min-width: 80px; }

        /* éŠæˆ²ä¸»å®¹å™¨ */
        #game-container {
            display: flex;
            width: 100%;
            flex: 1;
            justify-content: space-around;
            align-items: center;
            padding: 10px;
            box-sizing: border-box;
            height: calc(100vh - 50px);
        }

        .player-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 48%;
            height: 100%;
            position: relative;
        }

        .board-container {
            display: flex;
            gap: 15px;
            background: var(--panel-color);
            padding: 10px;
            border-radius: 10px;
            border: 2px solid #533483;
            max-height: 95%;
        }

        canvas {
            background: #000;
            border: 1px solid #333;
            height: auto;
            max-height: 80vh; 
        }

        .side-panel {
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            gap: 10px;
            width: 100px;
        }

        .info-box {
            background: #0f3460;
            padding: 5px;
            border-radius: 5px;
            text-align: center;
        }

        .info-label { font-size: 10px; color: #ccc; margin-bottom: 2px; }
        .info-value { font-size: 16px; font-weight: bold; color: #00d4ff; }

        /* æ–¹ç¨‹å¼è§£é¡Œå€ */
        .math-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 85%;
            background: rgba(15, 52, 96, 0.98);
            border: 4px solid var(--text-color);
            border-radius: 15px;
            padding: 15px;
            text-align: center;
            display: none; 
            z-index: 50;
            box-shadow: 0 0 50px rgba(0,0,0,0.9);
        }

        .math-equation {
            font-size: 20px;
            margin-bottom: 15px;
            color: #fff;
            background: #1a1a2e;
            padding: 10px;
            border-radius: 5px;
            word-break: break-all;
        }

        /* èªªæ˜è¦–çª— Overlay */
        #help-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95);
            z-index: 1000; 
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .help-content {
            background: #1a1a2e;
            padding: 30px;
            border-radius: 20px;
            max-width: 800px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            border: 2px solid #e94560;
            margin-top: 50px;
        }

        .help-table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0;
        }
        .help-table th, .help-table td {
            border: 1px solid #333;
            padding: 8px;
            text-align: left;
        }
        .help-table th { background: #0f3460; }

        #flash-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255, 0, 0, 0.5);
            pointer-events: none;
            z-index: 2000;
            opacity: 0;
            transition: opacity 0.05s;
        }

        /* éŠæˆ²çµæŸçµç®—ç•«é¢ */
        .global-game-over {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2100;
            overflow: hidden;
        }

        .win-celebration { 
            color: #ffcc00; 
            font-size: 56px; 
            margin-top: 10px; 
            font-weight: 900;
            text-shadow: 0 0 30px rgba(255, 204, 0, 0.8), 2px 2px 2px #000;
            animation: winPulse 1.5s infinite;
            text-align: center;
            z-index: 2110;
        }

        @keyframes winPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        /* èŠ±ç“£æ¨£å¼ */
        .petal {
            position: absolute;
            background-color: #ffc0cb;
            border-radius: 150% 0 150% 0;
            pointer-events: none;
            z-index: 2105;
        }

        @keyframes fall {
            0% { top: -10%; transform: translateX(0) rotate(0deg); }
            100% { top: 110%; transform: translateX(100px) rotate(360deg); }
        }

        .math-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .option-btn {
            padding: 12px;
            background: #533483;
            border: 2px solid transparent;
            color: white;
            border-radius: 8px;
            font-size: 18px;
            cursor: pointer;
        }

        .option-btn.selected {
            border-color: #00ffcc;
            background: #e94560;
        }

        /* åŠ åˆ†ç‰¹æ•ˆæ¨£å¼ */
        .score-pop {
            position: absolute;
            color: #00ffcc;
            font-weight: bold;
            font-size: 24px;
            animation: fadeUp 1.2s cubic-bezier(0.23, 1, 0.32, 1) forwards;
            pointer-events: none;
            text-shadow: 0 0 8px rgba(0, 255, 204, 0.8);
            z-index: 100;
        }

        @keyframes fadeUp {
            from { opacity: 1; transform: translate(-50%, 0); }
            to { opacity: 0; transform: translate(-50%, -80px); }
        }
    </style>
</head>
<body>

    <div id="flash-overlay"></div>

    <div id="top-bar">
        <div class="audio-controls">
            <button class="btn btn-fullscreen" onclick="toggleFullScreen()">â›¶ å…¨è¢å¹•åˆ‡æ›</button>
            <button class="btn btn-audio" id="bgm-toggle" onclick="toggleMusic()">éŸ³æ¨‚: é—œ</button>
            <button class="btn btn-audio" id="sfx-toggle" onclick="toggleSFX()">éŸ³æ•ˆ: é—œ</button>
            <div class="volume-control">
                <span>ğŸ”Š</span>
                <input type="range" class="volume-slider" id="volume-slider" min="0" max="1" step="0.1" value="0.5" oninput="updateVolume(this.value)">
            </div>
        </div>
        
        <div class="title-group">
            <div style="font-weight: bold; font-size: 18px;">ğŸ•¹ï¸ ä¸€å…ƒä¸€æ¬¡ä¿„ç¾…æ–¯(æ±èˆˆã„šæ°)</div>
        </div>

        <div>
            <button class="btn btn-start" id="main-start-btn" onclick="startGameSession()">é–‹å§‹æˆ°é¬¥</button>
            <button class="btn btn-restart" id="restart-btn" onclick="location.reload()">é‡æ–°é–‹å§‹</button>
        </div>
    </div>

    <div id="game-container">
        <!-- ç©å®¶ A (å·¦) -->
        <div id="player-a" class="player-section">
            <h3 style="margin: 5px; color: #00d4ff;">ç©å®¶ A</h3>
            <div class="board-container">
                <canvas id="canvas-a" width="200" height="400"></canvas>
                <div class="side-panel">
                    <div class="info-box">
                        <div class="info-label">NEXT</div>
                        <canvas id="next-a" width="60" height="60"></canvas>
                    </div>
                    <div class="info-box">
                        <div class="info-label">SCORE</div>
                        <div id="score-a" class="info-value">0</div>
                    </div>
                </div>
            </div>
            <div id="math-a" class="math-overlay">
                <div style="color: #ff4d4d; margin-bottom: 5px; font-weight: bold;">âš ï¸ è¢«æ”»æ“Šï¼è«‹è§£é¡Œè§£é–ï¼</div>
                <div class="math-equation" id="eq-a">x + 5 = 12</div>
                <div class="math-options" id="options-a"></div>
            </div>
        </div>

        <!-- ç©å®¶ B (å³) -->
        <div id="player-b" class="player-section">
            <h3 style="margin: 5px; color: #ff4d4d;">ç©å®¶ B</h3>
            <div class="board-container">
                <canvas id="canvas-b" width="200" height="400"></canvas>
                <div class="side-panel">
                    <div class="info-box">
                        <div class="info-label">NEXT</div>
                        <canvas id="next-b" width="60" height="60"></canvas>
                    </div>
                    <div class="info-box">
                        <div class="info-label">SCORE</div>
                        <div id="score-b" class="info-value">0</div>
                    </div>
                </div>
            </div>
            <div id="math-b" class="math-overlay">
                <div style="color: #ff4d4d; margin-bottom: 5px; font-weight: bold;">âš ï¸ è¢«æ”»æ“Šï¼è«‹è§£é¡Œè§£é–ï¼</div>
                <div class="math-equation" id="eq-b">2x - 4 = 10</div>
                <div class="math-options" id="options-b"></div>
            </div>
        </div>
    </div>

    <!-- çµç®—ç•«é¢ -->
    <div id="global-over" class="global-game-over">
        <div id="win-msg" class="win-celebration">ğŸ† æ­å–œ ç©å®¶ ç²å¾—æœ€çµ‚å‹åˆ©ï¼ ğŸ†</div>
        <button class="btn btn-help" style="margin-top:40px; padding: 15px 40px; font-size: 20px; color: white; z-index: 2120;" onclick="location.reload()">é‡æ–°å°æ±º</button>
    </div>

    <div id="help-overlay">
        <div class="help-content">
            <h2 style="text-align: center; color: var(--text-color);">ã€Šä¸€å…ƒä¸€æ¬¡ä¿„ç¾…æ–¯ã€‹è¦å‰‡èˆ‡æ“ä½œ</h2>
            
            <h3>ğŸ® æ“ä½œå°ç…§è¡¨</h3>
            <table class="help-table">
                <tr>
                    <th>åŠŸèƒ½</th>
                    <th>ç©å®¶ A (éµç›¤)</th>
                    <th>ç©å®¶ B (éµç›¤)</th>
                    <th>æ–æ¡¿ (Gamepad)</th>
                </tr>
                <tr>
                    <td>å·¦å³ç§»å‹•</td>
                    <td>A / D (å¯é•·æŒ‰)</td>
                    <td>å·¦ / å³ æ–¹å‘éµ (å¯é•·æŒ‰)</td>
                    <td>å·¦æ–æ¡¿ / åå­—éµ</td>
                </tr>
                <tr>
                    <td>åŠ é€Ÿä¸‹è½</td>
                    <td>S (é•·æŒ‰)</td>
                    <td>ä¸‹ æ–¹å‘éµ (é•·æŒ‰)</td>
                    <td>å·¦æ–æ¡¿ ä¸‹ (é•·æŒ‰)</td>
                </tr>
                <tr>
                    <td>æ—‹è½‰æ–¹å¡Š</td>
                    <td>W</td>
                    <td>ä¸Š æ–¹å‘éµ</td>
                    <td><strong>æŒ‰éˆ• 1 (â—¯ / B)</strong></td>
                </tr>
                <tr>
                    <td><strong>ç¢ºèªç­”æ¡ˆ</strong></td>
                    <td><strong>Q</strong></td>
                    <td><strong>Enter</strong></td>
                    <td><strong>æŒ‰éˆ• 0 (A)</strong></td>
                </tr>
                <tr>
                    <td>é¸æ“‡ç­”æ¡ˆ</td>
                    <td>A / D / W / S</td>
                    <td>æ–¹å‘éµ ä¸Šä¸‹å·¦å³</td>
                    <td>å·¦æ–æ¡¿ / åå­—éµ</td>
                </tr>
            </table>

            <div style="line-height: 1.6;">
                <h3>âš”ï¸ æ”»æ“Šã€è¨ˆåˆ†èˆ‡ç‚¸å½ˆ</h3>
                <ul>
                    <li><strong>æ¶ˆé™¤è¡Œæ•¸ç©åˆ†ï¼š</strong> 1è¡Œ: 1åˆ† / 2è¡Œ: 5åˆ† / 3è¡Œ: 25åˆ† / 4è¡Œ: 100åˆ†ã€‚</li>
                    <li><strong>ç‰¹æ®Š B æ–¹å¡Šï¼š</strong> éš¨æ©Ÿå‡ºç¾å« "B" çš„å°æ ¼ã€‚æ¶ˆæ‰å®ƒå¯ç²å¾—<strong>ç‚¸å½ˆ</strong>ã€‚</li>
                    <li><strong>ç‚¸å½ˆåŠŸèƒ½ï¼š</strong> ç‚¸å½ˆè½åœ°ç¢°åˆ°éšœç¤™æœƒ<strong>ç«‹å³å¼•çˆ†</strong>ï¼Œç‚¸æ¯€ 5x5 ç¯„åœå…§çš„æ‰€æœ‰æ–¹å¡Šã€‚</li>
                    <li><strong>æ•¸å­¸è§£é¡Œï¼š</strong> æ¶ˆé™¤ 1 è¡Œä»¥ä¸Šå³å¯æ”»æ“Šå°æ‰‹ï¼Œå°æ‰‹å¿…é ˆæ­£ç¢ºè§£é¡Œæ–¹å¯æ¢å¾©æ“ä½œã€‚</li>
                    <li><strong>å³æ™‚æ·˜æ±°ï¼š</strong> è‹¥åƒåœ¾è¡Œå°‡æ–¹å¡Šæ¨è‡³é ‚éƒ¨ï¼Œç„¡è«–æ˜¯å¦åœ¨è§£é¡Œä¸­éƒ½æœƒç«‹å³åˆ¤è¼¸ã€‚</li>
                    <li><strong>ä¿‚æ•¸é™åˆ¶ï¼š</strong> æ‰€æœ‰é¡Œç›®ä¹‹ä¿‚æ•¸ã€å¸¸æ•¸èˆ‡ç­”æ¡ˆçš†ä¸ç‚º 0ã€‚</li>
                </ul>
            </div>
            <p style="text-align: center; color: #ffcc00; font-weight: bold; margin-top: 20px;">
                è«‹é»æ“Šå³ä¸Šè§’ã€Œé–‹å§‹æˆ°é¬¥ã€å•Ÿå‹•éŠæˆ²èˆ‡éŸ³æ¨‚
            </p>
        </div>
    </div>

    <script>
        const COLS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = 20; 
        const COLORS = [
            null, 
            '#FF0D72', // 1: T
            '#0DC2FF', // 2: I
            '#0DFF72', // 3: S
            '#F538FF', // 4: Z
            '#FF8E0D', // 5: L
            '#FFE138', // 6: J
            '#3877FF', // 7: O
            '#777',    // 8: Garbage
            null,      // 9: Empty
            '#FFD700', // 10: Special B Block (Gold)
            '#FF4500'  // 11: Bomb (Orange-Red)
        ];
        
        const SHAPES = [
            [],
            [[0, 1, 0], [1, 1, 1], [0, 0, 0]],
            [[0, 2, 0, 0], [0, 2, 0, 0], [0, 2, 0, 0], [0, 2, 0, 0]],
            [[0, 3, 3], [3, 3, 0], [0, 0, 0]],
            [[4, 4, 0], [0, 4, 4], [0, 0, 0]],
            [[5, 0, 0], [5, 5, 5], [0, 0, 0]],
            [[0, 0, 6], [6, 6, 6], [0, 0, 0]],
            [[7, 7], [7, 7]]
        ];

        let isPaused = true;
        let isGameOver = false;

        // éŸ³æ¨‚èˆ‡éŸ³æ•ˆè³‡æº - ä¿®æ”¹ç‚ºæœ¬åœ°ç›®éŒ„æª”æ¡ˆèˆ‡ .mp3 æ ¼å¼
        const BGM_FILES = [
            'bgmusic(1).mp3',
            'bgmusic(2).mp3',
            'bgmusic(3).mp3',
            'bgmusic(4).mp3',
            'bgmusic(5).mp3',
            'bgmusic(6).mp3',
            'bgmusic(7).mp3'
        ];
        const SFX_FILE = 'stonefall.mp3';
        
        let currentBgmIndex = 0;
        let audioEnabled = true; 
        let sfxEnabled = true;   
        let currentVolume = 0.5;

        let bgmPlayer = new Audio();
        let sfxPlayer = new Audio();
        
        // éŸ³é‡æ§åˆ¶
        function updateVolume(val) {
            currentVolume = parseFloat(val);
            bgmPlayer.volume = currentVolume;
            sfxPlayer.volume = currentVolume;
        }

        function toggleFullScreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.warn(`Error attempting to enable full-screen mode: ${err.message}`);
                });
            } else {
                if (document.exitFullscreen) document.exitFullscreen();
            }
        }

        // æ’­æ”¾éŸ³æ•ˆå‡½æ•¸
        function playStonefall() {
            if (sfxEnabled) {
                sfxPlayer.src = SFX_FILE;
                sfxPlayer.volume = currentVolume;
                sfxPlayer.play().catch(e => console.error("SFX play error. Ensure stonefall.mp3 exists.", e));
            }
        }

        async function flashScreen() {
            const overlay = document.getElementById('flash-overlay');
            playStonefall();
            
            for (let i = 0; i < 3; i++) {
                overlay.style.opacity = '1';
                await new Promise(r => setTimeout(r, 80));
                overlay.style.opacity = '0';
                await new Promise(r => setTimeout(r, 80));
            }
        }

        function toggleMusic() {
            audioEnabled = !audioEnabled;
            updateAudioButtons();
            if (audioEnabled) {
                if (bgmPlayer.src) bgmPlayer.play(); else playNextBgm();
            } else {
                bgmPlayer.pause();
            }
        }

        function toggleSFX() {
            sfxEnabled = !sfxEnabled;
            updateAudioButtons();
        }

        function updateAudioButtons() {
            document.getElementById('bgm-toggle').innerText = `éŸ³æ¨‚: ${audioEnabled ? 'é–‹' : 'é—œ'}`;
            document.getElementById('sfx-toggle').innerText = `éŸ³æ•ˆ: ${sfxEnabled ? 'é–‹' : 'é—œ'}`;
        }

        function playNextBgm() {
            if (!audioEnabled) return;
            
            bgmPlayer.src = BGM_FILES[currentBgmIndex];
            bgmPlayer.volume = currentVolume;
            
            bgmPlayer.play().then(() => {
                console.log("Now playing:", BGM_FILES[currentBgmIndex]);
            }).catch(e => {
                console.error("Audio error for:", BGM_FILES[currentBgmIndex], ". Auto-skipping...");
                // å¦‚æœç›®å‰çš„æª”æ¡ˆå¤±æ•—ï¼Œè‡ªå‹•å˜—è©¦ä¸‹ä¸€é¦–
                currentBgmIndex = (currentBgmIndex + 1) % BGM_FILES.length;
                playNextBgm();
            });
            
            currentBgmIndex = (currentBgmIndex + 1) % BGM_FILES.length;
        }
        
        bgmPlayer.onended = playNextBgm;

        class MathEngine {
            static generateByLines(lines) {
                let a, b, c, d, f, x, eq;
                while (true) {
                    x = (Math.floor(Math.random() * 10) + 1) * (Math.random() > 0.5 ? 1 : -1);
                    if (x !== 0) break;
                }
                if (lines === 1) {
                    while (true) {
                        a = (Math.floor(Math.random() * 15) + 1) * (Math.random() > 0.5 ? 1 : -1);
                        b = x + a;
                        if (a !== 0 && b !== 0) break;
                    }
                    eq = `x ${a >= 0 ? '+' : '-'} ${Math.abs(a)} = ${b}`;
                } else if (lines === 2) {
                    while (true) {
                        a = (Math.floor(Math.random() * 5) + 2) * (Math.random() > 0.5 ? 1 : -1);
                        b = (Math.floor(Math.random() * 10) + 1) * (Math.random() > 0.5 ? 1 : -1);
                        c = a * x + b;
                        if (a !== 0 && b !== 0 && c !== 0) break;
                    }
                    eq = `${a}x ${b >= 0 ? '+' : '-'} ${Math.abs(b)} = ${c}`;
                } else if (lines === 3) {
                    while (true) {
                        a = (Math.floor(Math.random() * 4) + 2) * (Math.random() > 0.5 ? 1 : -1);
                        b = (Math.floor(Math.random() * 6) + 1) * (Math.random() > 0.5 ? 1 : -1);
                        c = a * (x + b);
                        if (a !== 0 && b !== 0 && c !== 0) break;
                    }
                    eq = `${a}(x ${b >= 0 ? '+' : '-'} ${Math.abs(b)}) = ${c}`;
                } else {
                    while (true) {
                        a = Math.floor(Math.random() * 3) + 2; 
                        b = Math.floor(Math.random() * 3) + 2; 
                        c = (Math.floor(Math.random() * 5) + 1) * (Math.random() > 0.5 ? 1 : -1);
                        d = (Math.floor(Math.random() * 5) + 1) * (Math.random() > 0.5 ? 1 : -1);
                        f = (a * b - 1) * x + a * c + d;
                        if (a !== 0 && b !== 0 && c !== 0 && d !== 0 && f !== 0) break;
                    }
                    const cSign = c >= 0 ? '+' : '-';
                    const dSign = d >= 0 ? '+' : '-';
                    const fSign = f >= 0 ? '+' : '-';
                    eq = `${a}(${b}x ${cSign} ${Math.abs(c)}) ${dSign} ${Math.abs(d)} = x ${fSign} ${Math.abs(f)}`;
                }
                let options = this.shuffle([x, x+1, x-1, x+2]);
                return { equation: eq, answer: x, options };
            }
            static shuffle(arr) { return arr.sort(() => Math.random() - 0.5); }
        }

        class Player {
            constructor(id, canvasId, nextId, scoreId, mathId) {
                this.id = id;
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.nextCanvas = document.getElementById(nextId);
                this.nextCtx = this.nextCanvas.getContext('2d');
                this.scoreElement = document.getElementById(scoreId);
                this.mathUI = document.getElementById(mathId);
                
                this.board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
                this.score = 0;
                this.pos = { x: 0, y: 0 };
                this.matrix = null;
                this.nextMatrix = null;
                this.isBombActive = false;
                this.bombIsNext = false; 
                
                this.keyboardLeft = false;
                this.keyboardRight = false;
                this.keyboardDown = false;
                this.gamepadLeft = false;
                this.gamepadRight = false;
                this.gamepadDown = false;
                
                this.waitReleaseDown = false; 
                this.moveCounter = 0; 
                this.moveInterval = 100; 
                this.dasDelay = 200; 
                this.moveLocked = false; 
                this.keys = { left: false, right: false }; 

                this.dropCounter = 0;
                this.dropInterval = 1000;
                this.isSolving = false;
                this.currentProblem = null;
                this.mathDifficulty = 1;
                this.selectedIndex = 0;
                this.lastGamepadState = { left: false, right: false, up: false, down: false, btn0: false, btn1: false };
                
                this.setNextPiece(); 
                this.resetPiece();
            }

            setNextPiece() {
                const type = (Math.random() * 7 | 0) + 1;
                let matrix = SHAPES[type].map(row => [...row]);
                if (Math.random() < 0.2) {
                    let blocks = [];
                    matrix.forEach((row, y) => row.forEach((v, x) => { if (v) blocks.push({x, y}); }));
                    if (blocks.length > 0) {
                        const target = blocks[Math.floor(Math.random() * blocks.length)];
                        matrix[target.y][target.x] = 10; 
                    }
                }
                this.nextMatrix = matrix;
            }

            resetPiece() {
                if (this.bombIsNext) {
                    this.matrix = [[11]];
                    this.isBombActive = true;
                    this.bombIsNext = false;
                } else {
                    this.matrix = this.nextMatrix;
                    this.isBombActive = false;
                    this.setNextPiece();
                }
                
                this.pos.y = 0;
                this.pos.x = (COLS / 2 | 0) - (this.matrix[0].length / 2 | 0);
                this.waitReleaseDown = true; 
                if (this.collide()) endGame(this.id);
                this.drawNext();
            }

            collide(offset = { x: 0, y: 0 }) {
                const m = this.matrix;
                const p = this.pos;
                for (let y = 0; y < m.length; ++y) {
                    for (let x = 0; x < m[y].length; ++x) {
                        if (m[y][x] !== 0) {
                            const newY = y + p.y + offset.y;
                            const newX = x + p.x + offset.x;
                            if (newX < 0 || newX >= COLS || newY >= ROWS) return true;
                            if (newY >= 0 && this.board[newY][newX] !== 0) return true;
                        }
                    }
                }
                return false;
            }

            drop() {
                if (this.isSolving || isGameOver || isPaused) return;
                this.pos.y++;
                if (this.collide()) {
                    this.pos.y--;
                    if (this.isBombActive) {
                        this.explode();
                        this.resetPiece();
                    } else {
                        this.join();
                        this.sweep();
                        this.resetPiece();
                    }
                }
                this.dropCounter = 0;
            }

            explode() {
                const centerX = this.pos.x;
                const centerY = this.pos.y;
                for (let y = centerY - 2; y <= centerY + 2; y++) {
                    for (let x = centerX - 2; x <= centerX + 2; x++) {
                        if (y >= 0 && y < ROWS && x >= 0 && x < COLS) {
                            this.board[y][x] = 0;
                        }
                    }
                }
                flashScreen();
            }

            move(dir) {
                if (isGameOver || isPaused || this.isSolving) return;
                this.pos.x += dir;
                if (this.collide()) {
                    this.pos.x -= dir;
                    return false;
                }
                return true;
            }

            selectMathOption(dirX, dirY) {
                if (!this.isSolving) return;
                let newIndex = this.selectedIndex;
                if (dirX !== 0) {
                    const row = Math.floor(newIndex / 2);
                    newIndex = row * 2 + (newIndex % 2 + dirX + 2) % 2;
                }
                if (dirY !== 0) {
                    newIndex = (newIndex + dirY * 2 + 4) % 4;
                }
                this.selectedIndex = newIndex;
                this.renderMath();
            }

            rotate() {
                if (this.isSolving || isGameOver || isPaused || this.isBombActive) return;
                const m = this.matrix;
                for (let y = 0; y < m.length; ++y) {
                    for (let x = 0; x < y; ++x) {
                        [m[x][y], m[y][x]] = [m[y][x], m[x][y]];
                    }
                }
                m.forEach(row => row.reverse());
                if (this.collide()) {
                    m.forEach(row => row.reverse());
                    for (let y = 0; y < m.length; ++y) {
                        for (let x = 0; x < y; ++x) {
                            [m[x][y], m[y][x]] = [m[y][x], m[x][y]];
                        }
                    }
                }
            }

            join() {
                this.matrix.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value !== 0) {
                            const newY = y + this.pos.y;
                            if (newY >= 0) this.board[newY][x + this.pos.x] = value;
                        }
                    });
                });
            }

            sweep() {
                let rowCount = 0;
                let hasSpecial = false;
                outer: for (let y = ROWS - 1; y >= 0; --y) {
                    let full = true;
                    for (let x = 0; x < COLS; ++x) { 
                        if (this.board[y][x] === 0) { full = false; break; }
                    }
                    if (!full) continue outer;

                    for (let x = 0; x < COLS; ++x) {
                        if (this.board[y][x] === 10) hasSpecial = true;
                    }

                    this.board.splice(y, 1);
                    this.board.unshift(Array(COLS).fill(0));
                    ++y;
                    rowCount++;
                }

                if (rowCount > 0) {
                    const scores = [0, 1, 5, 25, 100];
                    const add = scores[rowCount] || 0;
                    this.score += add;
                    this.scoreElement.innerText = this.score;
                    this.showPopScore(add);

                    const opponent = (this.id === 'A') ? playerB : playerA;
                    opponent.receiveAttack(rowCount);
                    opponent.triggerMath(rowCount);
                    flashScreen();

                    if (hasSpecial) {
                        this.bombIsNext = true; 
                    }
                }
            }

            receiveAttack(lines) {
                for (let i = 0; i < lines; i++) {
                    const topRowOccupied = this.board[0].some(val => val !== 0);
                    const row = Array(COLS).fill(8);
                    row[Math.floor(Math.random() * COLS)] = 0;
                    this.board.shift();
                    this.board.push(row);
                    if (topRowOccupied || this.collide()) {
                        endGame(this.id);
                        return;
                    }
                }
            }

            triggerMath(lines) {
                if (lines < 1) return; 
                this.isSolving = true;
                this.mathDifficulty = lines;
                this.currentProblem = MathEngine.generateByLines(lines);
                this.selectedIndex = 0;
                this.mathUI.style.display = 'block';
                this.renderMath();
            }

            renderMath() {
                const eqDiv = this.mathUI.querySelector('.math-equation');
                const optDiv = this.mathUI.querySelector('.math-options');
                eqDiv.innerText = this.currentProblem.equation;
                optDiv.innerHTML = '';
                this.currentProblem.options.forEach((opt, i) => {
                    const btn = document.createElement('div');
                    btn.className = `option-btn ${i === this.selectedIndex ? 'selected' : ''}`;
                    btn.innerText = opt;
                    optDiv.appendChild(btn);
                });
            }

            confirmAnswer() {
                if (!this.isSolving) return;
                if (this.currentProblem.options[this.selectedIndex] === this.currentProblem.answer) {
                    this.isSolving = false;
                    this.mathUI.style.display = 'none';
                } else {
                    this.receiveAttack(1);
                    this.currentProblem = MathEngine.generateByLines(1);
                    this.renderMath();
                }
            }

            showPopScore(val) {
                const pop = document.createElement('div');
                pop.className = 'score-pop';
                pop.innerText = `+${val}`;
                pop.style.left = '50%';
                pop.style.top = '45%';
                this.canvas.parentElement.appendChild(pop);
                setTimeout(() => pop.remove(), 1200);
            }

            draw() {
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.drawMatrix(this.board, { x: 0, y: 0 });
                this.drawMatrix(this.matrix, this.pos);
                if (this.isSolving) {
                    this.ctx.fillStyle = 'rgba(255, 0, 0, 0.2)';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                }
            }

            drawMatrix(matrix, offset) {
                matrix.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value !== 0) {
                            const px = (x + offset.x) * BLOCK_SIZE;
                            const py = (y + offset.y) * BLOCK_SIZE;
                            
                            if (value === 11) { // Bomb
                                this.ctx.fillStyle = COLORS[11];
                                this.ctx.beginPath();
                                this.ctx.arc(px + BLOCK_SIZE/2, py + BLOCK_SIZE/2, BLOCK_SIZE/2 - 1, 0, Math.PI*2);
                                this.ctx.fill();
                                this.ctx.strokeStyle = '#fff';
                                this.ctx.stroke();
                            } else {
                                this.ctx.fillStyle = COLORS[value];
                                this.ctx.fillRect(px, py, BLOCK_SIZE, BLOCK_SIZE);
                                this.ctx.strokeStyle = '#111';
                                this.ctx.strokeRect(px, py, BLOCK_SIZE, BLOCK_SIZE);
                                if (value === 10) {
                                    this.ctx.fillStyle = '#000';
                                    this.ctx.font = 'bold 14px Segoe UI';
                                    this.ctx.textAlign = 'center';
                                    this.ctx.fillText('B', px + BLOCK_SIZE/2, py + BLOCK_SIZE - 5);
                                }
                            }
                        }
                    });
                });
            }

            drawNext() {
                this.nextCtx.fillStyle = '#0f3460';
                this.nextCtx.fillRect(0, 0, 60, 60);
                const m = this.bombIsNext ? [[11]] : this.nextMatrix;
                const s = 12;
                m.forEach((row, y) => { row.forEach((v, x) => {
                    if (v) {
                        this.nextCtx.fillStyle = COLORS[v];
                        if (v === 11) {
                            this.nextCtx.beginPath();
                            this.nextCtx.arc(10 + x*s + s/2, 10 + y*s + s/2, s/2, 0, Math.PI*2);
                            this.nextCtx.fill();
                        } else {
                            this.nextCtx.fillRect(10 + x*s, 10 + y*s, s, s);
                        }
                    }
                })});
            }

            updateMovement(dt) {
                if (this.isSolving || isGameOver || isPaused) return;
                
                const left = this.keyboardLeft || this.gamepadLeft;
                const right = this.keyboardRight || this.gamepadRight;
                let moveDir = 0;
                if (left) moveDir = -1;
                else if (right) moveDir = 1;
                if (moveDir !== 0) {
                    if (!this.moveLocked) {
                        this.move(moveDir);
                        this.moveLocked = true;
                        this.moveCounter = 0;
                    } else {
                        this.moveCounter += dt;
                        if (this.moveCounter > this.dasDelay) {
                            if (this.moveCounter - this.dasDelay > this.moveInterval) {
                                this.move(moveDir);
                                this.moveCounter = this.dasDelay; 
                            }
                        }
                    }
                } else {
                    this.moveLocked = false;
                }
            }
        }

        const playerA = new Player('A', 'canvas-a', 'next-a', 'score-a', 'math-a');
        const playerB = new Player('B', 'canvas-b', 'next-b', 'score-b', 'math-b');

        window.addEventListener('keydown', e => {
            if (isPaused || isGameOver) return;
            const code = e.code;
            if (code === 'KeyA') {
                if (playerA.isSolving) playerA.selectMathOption(-1, 0);
                else { playerA.keyboardLeft = true; }
            }
            if (code === 'KeyD') {
                if (playerA.isSolving) playerA.selectMathOption(1, 0);
                else { playerA.keyboardRight = true; }
            }
            if (code === 'KeyS') {
                if (playerA.isSolving) playerA.selectMathOption(0, 1);
                else playerA.keyboardDown = true;
            }
            if (code === 'KeyW') {
                if (playerA.isSolving) playerA.selectMathOption(0, -1);
                else playerA.rotate();
            }
            if ((code === 'KeyQ' || code === 'KeyE') && playerA.isSolving) playerA.confirmAnswer();

            if (code === 'ArrowLeft') {
                if (playerB.isSolving) playerB.selectMathOption(-1, 0);
                else { playerB.keyboardLeft = true; }
            }
            if (code === 'ArrowRight') {
                if (playerB.isSolving) playerB.selectMathOption(1, 0);
                else { playerB.keyboardRight = true; }
            }
            if (code === 'ArrowDown') {
                if (playerB.isSolving) playerB.selectMathOption(0, 1);
                else playerB.keyboardDown = true;
            }
            if (code === 'ArrowUp') {
                if (playerB.isSolving) playerB.selectMathOption(0, -1);
                else playerB.rotate();
            }
            if (code === 'Enter' && playerB.isSolving) playerB.confirmAnswer();
        });

        window.addEventListener('keyup', e => {
            const code = e.code;
            if (code === 'KeyA') playerA.keyboardLeft = false;
            if (code === 'KeyD') playerA.keyboardRight = false;
            if (code === 'KeyS') { playerA.keyboardDown = false; playerA.waitReleaseDown = false; }
            if (code === 'ArrowLeft') playerB.keyboardLeft = false;
            if (code === 'ArrowRight') playerB.keyboardRight = false;
            if (code === 'ArrowDown') { playerB.keyboardDown = false; playerB.waitReleaseDown = false; }
        });

        function pollGamepads() {
            const gamepads = navigator.getGamepads();
            if (!gamepads) return;
            [playerA, playerB].forEach((p, i) => {
                const gp = gamepads[i];
                if (!gp) return;
                
                const axisDown = gp.axes[1] > 0.5 || gp.buttons[13]?.pressed;
                const axisUp = gp.axes[1] < -0.5 || gp.buttons[12]?.pressed;
                const axisLeft = gp.axes[0] < -0.5 || gp.buttons[14]?.pressed;
                const axisRight = gp.axes[0] > 0.5 || gp.buttons[15]?.pressed;
                const btn0 = gp.buttons[0].pressed; 
                const btn1 = gp.buttons[1].pressed; 

                if (!axisDown) p.waitReleaseDown = false; 

                if (p.isSolving) {
                    if (axisLeft && !p.lastGamepadState.left) p.selectMathOption(-1, 0);
                    if (axisRight && !p.lastGamepadState.right) p.selectMathOption(1, 0);
                    if (axisDown && !p.lastGamepadState.down) p.selectMathOption(0, 1);
                    if (axisUp && !p.lastGamepadState.up) p.selectMathOption(0, -1);
                    if (btn0 && !p.lastGamepadState.btn0) p.confirmAnswer(); 
                } else {
                    p.gamepadLeft = axisLeft;
                    p.gamepadRight = axisRight;
                    p.gamepadDown = axisDown && !p.waitReleaseDown;
                    if (btn1 && !p.lastGamepadState.btn1) p.rotate(); 
                }
                p.lastGamepadState = { left: axisLeft, right: axisRight, up: axisUp, down: axisDown, btn0, btn1 };
            });
        }

        let lastTime = 0;
        function update(time = 0) {
            const dt = time - lastTime;
            lastTime = time;
            pollGamepads();
            [playerA, playerB].forEach(p => {
                p.updateMovement(dt);
                if (!p.isSolving && !isGameOver && !isPaused) {
                    p.dropCounter += dt;
                    const isSoftDrop = p.keyboardDown || p.gamepadDown;
                    const currentInterval = isSoftDrop ? 50 : p.dropInterval;
                    if (p.dropCounter > currentInterval) { p.drop(); p.dropCounter = 0; }
                }
                p.draw();
            });
            requestAnimationFrame(update);
        }

        function createPetals() {
            const container = document.getElementById('global-over');
            const colors = ['#ffc0cb', '#ff69b4', '#ff1493', '#fff', '#ffd700'];
            for (let i = 0; i < 100; i++) {
                const petal = document.createElement('div');
                petal.className = 'petal';
                const size = Math.random() * 10 + 10;
                petal.style.width = size + 'px';
                petal.style.height = size + 'px';
                petal.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                petal.style.left = Math.random() * 100 + '%';
                petal.style.animation = `fall ${Math.random() * 3 + 2}s linear infinite`;
                petal.style.animationDelay = Math.random() * 5 + 's';
                petal.style.opacity = Math.random();
                container.appendChild(petal);
            }
        }

        function endGame(loserId) {
            if (isGameOver) return;
            isGameOver = true;
            const winner = loserId === 'A' ? 'B' : 'A';
            const winMsg = document.getElementById('win-msg');
            winMsg.innerText = `ğŸ† æ­å–œ ç©å®¶ ${winner} ç²å¾—æœ€çµ‚å‹åˆ©ï¼ ğŸ†`;
            document.getElementById('global-over').style.display = 'flex';
            createPetals(); 
            bgmPlayer.pause();
        }

        function startGameSession() {
            isPaused = false;
            isGameOver = false;
            document.getElementById('help-overlay').style.display = 'none';
            document.getElementById('main-start-btn').style.display = 'none';
            document.getElementById('restart-btn').style.display = 'block'; 
            updateAudioButtons();
            
            if (audioEnabled) {
                currentBgmIndex = 0;
                playNextBgm();
            }
        }

        update();
        document.getElementById('help-overlay').style.display = 'flex';
    </script>
</body>
</html>
